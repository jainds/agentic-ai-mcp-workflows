name: üöÄ CI/CD Pipeline with Auto-Versioning & Multi-Image Publishing

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*.*.*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      version_bump:
        description: 'Version bump type'
        required: false
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip test execution'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}

jobs:
  # ==========================================
  # Version Management & Tagging
  # ==========================================
  version:
    name: üè∑Ô∏è Version Management
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      previous-version: ${{ steps.version.outputs.previous-version }}
      tag: ${{ steps.version.outputs.tag }}
      changelog: ${{ steps.version.outputs.changelog }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üìù Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: üîç Determine version bump
        id: version
        run: |
          # Get current version from pyproject.toml
          CURRENT_VERSION=$(grep '^version = ' pyproject.toml | sed 's/version = "\(.*\)"/\1/')
          echo "Current version: $CURRENT_VERSION"
          
          # Determine version bump type
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            BUMP_TYPE="${{ github.event.inputs.version_bump }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            # Check commit messages for version hints
            COMMITS=$(git log --oneline --since="$(git describe --tags --abbrev=0 2>/dev/null || echo '1 day ago')" | head -20)
            if echo "$COMMITS" | grep -iE "\b(break|breaking|major)\b"; then
              BUMP_TYPE="major"
            elif echo "$COMMITS" | grep -iE "\b(feat|feature|minor)\b"; then
              BUMP_TYPE="minor"
            else
              BUMP_TYPE="patch"
            fi
          else
            BUMP_TYPE="patch"
          fi
          
          echo "Version bump type: $BUMP_TYPE"
          
          # Calculate new version
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}
          
          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          
          # Add pre-release suffix for non-main branches
          if [[ "${{ github.ref }}" != "refs/heads/main" ]]; then
            BRANCH_NAME=$(echo "${{ github.ref_name }}" | sed 's/[^a-zA-Z0-9]/-/g')
            NEW_VERSION="$NEW_VERSION-$BRANCH_NAME.$(date +%Y%m%d%H%M%S)"
          fi
          
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "previous-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Generate changelog
          CHANGELOG=$(git log --oneline --since="$(git describe --tags --abbrev=0 2>/dev/null || echo '1 day ago')" | head -10 | sed 's/^/- /')
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: üìù Update version in pyproject.toml
        if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
        run: |
          sed -i 's/^version = .*/version = "${{ steps.version.outputs.version }}"/' pyproject.toml
          git add pyproject.toml
          git commit -m "üîñ Bump version to ${{ steps.version.outputs.version }}" || echo "No changes to commit"

      - name: üè∑Ô∏è Create and push tag
        if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
        run: |
          git tag -a "${{ steps.version.outputs.tag }}" -m "Release ${{ steps.version.outputs.tag }}"
          git push origin "${{ steps.version.outputs.tag }}" || echo "Tag already exists"
          git push origin main || echo "No changes to push"

  # ==========================================
  # Build and Test
  # ==========================================
  build-and-test:
    name: üèóÔ∏è Build & Test
    needs: version
    runs-on: ubuntu-latest
    outputs:
      images: ${{ steps.meta.outputs.images }}
      image-tags: ${{ steps.meta.outputs.tags }}
      test-results: ${{ steps.test.outputs.results }}
    strategy:
      matrix:
        image:
          - name: main
            dockerfile: Dockerfile
            context: .
          - name: adk
            dockerfile: Dockerfile.adk
            context: .
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.13'
          cache: 'pip'

      - name: üß™ Run comprehensive tests
        id: test
        if: ${{ !github.event.inputs.skip_tests && matrix.image.name == 'main' }}
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-json-report
          
          echo "Running unit tests..."
          python -m pytest tests/unit/ -v \
            --cov=. --cov-report=xml --cov-report=term \
            --json-report --json-report-file=unit-test-results.json || true
          
          echo "Running integration tests..."
          python -m pytest tests/integration/ -v \
            --json-report --json-report-file=integration-test-results.json || true
          
          # Extract test summary
          if [ -f unit-test-results.json ]; then
            unit_tests=$(cat unit-test-results.json | jq -r '.summary.total // 0')
            unit_passed=$(cat unit-test-results.json | jq -r '.summary.passed // 0')
            echo "results=Unit: $unit_passed/$unit_tests passed" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üè∑Ô∏è Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ matrix.image.name }}
          tags: |
            type=raw,value=${{ needs.version.outputs.version }}
            type=raw,value=latest,enable={{is_default_branch}}
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value={{date 'YYYYMMDD-HHmmss'}},suffix=-${{ matrix.image.name }}
          labels: |
            org.opencontainers.image.title=Insurance AI PoC (${{ matrix.image.name }})
            org.opencontainers.image.description=Google ADK + LiteLLM + OpenRouter Integration (${{ matrix.image.name }})
            org.opencontainers.image.version=${{ needs.version.outputs.version }}
            org.opencontainers.image.vendor=Insurance AI Team
            insurance.ai.component=${{ matrix.image.name }}
            insurance.ai.version=${{ needs.version.outputs.version }}

      - name: üê≥ Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.image.context }}
          file: ${{ matrix.image.dockerfile }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=${{ matrix.image.name }}
          cache-to: type=gha,mode=max,scope=${{ matrix.image.name }}
          platforms: linux/amd64,linux/arm64
          build-args: |
            VERSION=${{ needs.version.outputs.version }}
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=${{ github.sha }}

      - name: üîç Test image
        run: |
          # Test that the image can be pulled and runs
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ matrix.image.name }}:${{ needs.version.outputs.version }}
          docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ matrix.image.name }}:${{ needs.version.outputs.version }} \
            python --version

      - name: Upload test artifacts
        uses: actions/upload-artifact@v3
        if: always() && matrix.image.name == 'main'
        with:
          name: test-results
          path: |
            unit-test-results.json
            integration-test-results.json
            coverage.xml

  # ==========================================
  # Security Scanning
  # ==========================================
  security-scan:
    name: üîí Security Scan
    needs: [version, build-and-test]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image-name: [main, adk]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ matrix.image-name }}:${{ needs.version.outputs.version }}
          format: 'sarif'
          output: 'trivy-results-${{ matrix.image-name }}.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results-${{ matrix.image-name }}.sarif'

  # ==========================================
  # Deploy to Staging
  # ==========================================
  deploy-staging:
    name: üöÄ Deploy to Staging
    needs: [version, build-and-test, security-scan]
    runs-on: ubuntu-latest
    environment: staging
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.13.0'

      - name: üîß Configure kubectl for staging
        run: |
          echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > $HOME/.kube/config
          kubectl config use-context default || true
          kubectl create namespace insurance-ai-staging --dry-run=client -o yaml | kubectl apply -f -

      - name: üìä Deploy to staging with Helm
        run: |
          helm upgrade --install insurance-ai-poc ./k8s/insurance-ai-poc \
            --namespace insurance-ai-staging \
            --create-namespace \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }} \
            --set image.tag=${{ needs.version.outputs.version }} \
            --set image.mainImage=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-main:${{ needs.version.outputs.version }} \
            --set image.adkImage=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-adk:${{ needs.version.outputs.version }} \
            --set environment=staging \
            --set version="${{ needs.version.outputs.version }}" \
            --set replicaCount=1 \
            --set resources.requests.cpu=200m \
            --set resources.requests.memory=512Mi \
            --set resources.limits.cpu=1000m \
            --set resources.limits.memory=2Gi \
            --set secrets.openrouterApiKey="${{ secrets.OPENROUTER_API_KEY }}" \
            --set secrets.openaiApiKey="${{ secrets.OPENAI_API_KEY }}" \
            --set secrets.langfuseSecretKey="${{ secrets.LANGFUSE_SECRET_KEY }}" \
            --set secrets.langfusePublicKey="${{ secrets.LANGFUSE_PUBLIC_KEY }}" \
            --wait --timeout=10m

      - name: ‚è≥ Wait for deployment to be ready
        run: |
          kubectl wait --for=condition=available deployment \
            -l app.kubernetes.io/instance=insurance-ai-poc \
            --timeout=300s \
            -n insurance-ai-staging

      - name: üîç Get deployment status
        run: |
          kubectl get pods -n insurance-ai-staging
          kubectl get services -n insurance-ai-staging

  # ==========================================
  # E2E Tests
  # ==========================================
  e2e-tests:
    name: üéØ E2E Tests
    needs: [version, build-and-test, deploy-staging]
    runs-on: ubuntu-latest
    if: needs.deploy-staging.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.13'
          cache: 'pip'

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: üîß Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > $HOME/.kube/config

      - name: üåê Set up port forwarding for E2E tests
        run: |
          # Start port forwarding in background
          kubectl port-forward -n insurance-ai-staging service/insurance-adk-customer-service 8000:8000 &
          kubectl port-forward -n insurance-ai-staging service/insurance-adk-technical 8001:8001 &
          kubectl port-forward -n insurance-ai-staging service/insurance-adk-orchestrator 8002:8002 &
          kubectl port-forward -n insurance-ai-staging service/policy-server 8003:8001 &
          kubectl port-forward -n insurance-ai-staging service/streamlit-ui 8501:8501 &
          
          # Wait for port forwards to be ready
          sleep 30

      - name: üß™ Run E2E tests
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-json-report
          
          # Run E2E tests with staging endpoints
          python tests/verify_monitoring_integration.py || true
        env:
          ADK_CUSTOMER_SERVICE_URL: http://localhost:8000
          ADK_TECHNICAL_AGENT_URL: http://localhost:8001
          ADK_ORCHESTRATOR_URL: http://localhost:8002
          POLICY_SERVER_URL: http://localhost:8003
          STREAMLIT_URL: http://localhost:8501

  # ==========================================
  # Production Deployment
  # ==========================================
  deploy-production:
    name: üöÄ Production Deployment
    needs: [version, build-and-test, e2e-tests]
    runs-on: ubuntu-latest
    environment: production
    if: |
      (needs.e2e-tests.result == 'success' || github.event.inputs.force_deploy == 'true') &&
      (github.ref == 'refs/heads/main' || github.event.inputs.environment == 'production')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.13.0'

      - name: üîß Configure kubectl for production
        run: |
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
          kubectl config use-context default || true
          kubectl create namespace insurance-ai-production --dry-run=client -o yaml | kubectl apply -f -

      - name: üìä Deploy to production with Helm
        run: |
          helm upgrade --install insurance-ai-poc ./k8s/insurance-ai-poc \
            --namespace insurance-ai-production \
            --create-namespace \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }} \
            --set image.tag=${{ needs.version.outputs.version }} \
            --set image.mainImage=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-main:${{ needs.version.outputs.version }} \
            --set image.adkImage=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-adk:${{ needs.version.outputs.version }} \
            --set environment=production \
            --set version="${{ needs.version.outputs.version }}" \
            --set replicaCount=2 \
            --set resources.requests.cpu=500m \
            --set resources.requests.memory=1Gi \
            --set resources.limits.cpu=2000m \
            --set resources.limits.memory=4Gi \
            --set autoscaling.enabled=true \
            --set autoscaling.minReplicas=2 \
            --set autoscaling.maxReplicas=10 \
            --set autoscaling.targetCPUUtilizationPercentage=70 \
            --set secrets.openrouterApiKey="${{ secrets.OPENROUTER_API_KEY }}" \
            --set secrets.openaiApiKey="${{ secrets.OPENAI_API_KEY }}" \
            --set secrets.langfuseSecretKey="${{ secrets.LANGFUSE_SECRET_KEY }}" \
            --set secrets.langfusePublicKey="${{ secrets.LANGFUSE_PUBLIC_KEY }}" \
            --wait --timeout=15m

      - name: ‚è≥ Wait for production deployment
        run: |
          kubectl wait --for=condition=available deployment \
            -l app.kubernetes.io/instance=insurance-ai-poc \
            --timeout=600s \
            -n insurance-ai-production

      - name: üîç Verify production deployment
        run: |
          kubectl get pods -n insurance-ai-production
          kubectl get services -n insurance-ai-production
          kubectl get hpa -n insurance-ai-production

  # ==========================================
  # Create GitHub Release
  # ==========================================
  create-release:
    name: üì¶ Create GitHub Release
    needs: [version, build-and-test, deploy-staging]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.version.outputs.tag }}
          release_name: Release ${{ needs.version.outputs.tag }}
          body: |
            ## üöÄ Release ${{ needs.version.outputs.tag }}
            
            ### üì¶ Docker Images Published
            - `${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-main:${{ needs.version.outputs.version }}`
            - `${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-adk:${{ needs.version.outputs.version }}`
            
            ### üìù Changes
            ${{ needs.version.outputs.changelog }}
            
            ### üîß Deployment Commands
            ```bash
            # Pull latest images
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-main:${{ needs.version.outputs.version }}
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-adk:${{ needs.version.outputs.version }}
            
            # Deploy with Helm
            helm upgrade --install insurance-ai-poc ./k8s/insurance-ai-poc \
              --set image.tag=${{ needs.version.outputs.version }}
            ```
          draft: false
          prerelease: false

  # ==========================================
  # Package Vulnerability Report
  # ==========================================
  vulnerability-report:
    name: üìä Generate Vulnerability Report
    needs: [version, security-scan]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Create vulnerability summary
        run: |
          echo "## üîí Security Scan Summary" > vulnerability-report.md
          echo "Version: ${{ needs.version.outputs.version }}" >> vulnerability-report.md
          echo "Scan Date: $(date)" >> vulnerability-report.md
          echo "" >> vulnerability-report.md
          echo "### Images Scanned:" >> vulnerability-report.md
          echo "- insurance-ai-poc-main:${{ needs.version.outputs.version }}" >> vulnerability-report.md
          echo "- insurance-ai-poc-adk:${{ needs.version.outputs.version }}" >> vulnerability-report.md

      - name: Upload vulnerability report
        uses: actions/upload-artifact@v3
        with:
          name: vulnerability-report
          path: vulnerability-report.md

  # ==========================================
  # Notifications
  # ==========================================
  notify:
    name: üì¢ Notify Team
    needs: [version, build-and-test, deploy-staging, e2e-tests, deploy-production, create-release]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Create deployment summary
        id: summary
        run: |
          if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            STATUS="üéâ Production deployment successful!"
            COLOR="good"
          elif [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            STATUS="‚úÖ Staging deployment successful"
            COLOR="warning"
          else
            STATUS="‚ùå Deployment failed"
            COLOR="danger"
          fi
          
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "color=$COLOR" >> $GITHUB_OUTPUT

      - name: Slack notification
        if: ${{ secrets.SLACK_WEBHOOK_URL }}
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ steps.summary.outputs.color }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: |
            ${{ steps.summary.outputs.status }}
            
            **Version:** ${{ needs.version.outputs.version }}
            **Images Published:**
            - `${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-main:${{ needs.version.outputs.version }}`
            - `${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-adk:${{ needs.version.outputs.version }}`
            
            **Pipeline Results:**
            **Build:** ${{ needs.build-and-test.result }}
            **Tests:** ${{ needs.build-and-test.outputs.test-results }}
            **Staging:** ${{ needs.deploy-staging.result }}
            **E2E Tests:** ${{ needs.e2e-tests.result }}
            **Production:** ${{ needs.deploy-production.result }}
            **Release:** ${{ needs.create-release.result }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} 